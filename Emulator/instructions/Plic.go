package instructions

// https://five-embeddev.com/riscv-priv-isa-manual/Priv-v1.12/plic.html
// PLIC treats each interrupt target as independent. The targets are the harts.
// A hart can have local interrupt sources like software interrupts or timer interrupts which don't pass through PLIC.
// In this case, the cause of interrupt can be seen in mcause register.
// Global interrupts are handled by PLIC.

// For interrupt gateways, if an interrupt is pending, no new interrupts are considered, until the pending
// ones are completed.

// Interrupt sources are assigned a unique unsigned identifiers called interrupt identifers starting with 1.
// ID 0 means no interrupts. Smaller interrupt ID takes precedence over larger values when priorities of interrupts
// are same.

// All interrupt priorities can be hardwired to 1 for us.

// Each interrupt target has a vector of interrupt enable bits, one per interrupt source.
// Can be hardwired to 0 or 1. We can do a 1.

// interrupt priority thresholds can be wired to 0.

// Interrupt notifications generated by the PLIC appear
//in the  meip/seip/ueip bits of the mip/sip/ uip registers for M/S/U modes, respectively.
//For the notifications to appear in lower-privilege xip registers,
//the corresponding external interrupts must have been delegated in the higher-privilege yideleg registers.
// Each privilege level is an interrupt source.

// The PLIC hardware only supports multicasting of interrupts, such that all enabled targets will receive
// interrupt notifications for a given active interrupt.

// interrupt claims
// When a target gets notification, it might service the interrupt. Target sends an interrupt claim message to PLIC
// usually as a MMIO register read. PLIC will then give the ID of highest priority pending interrupt for target
// and then clear corresponding source's IP bit. 0 will be returned if there is no pending interrupts.

// interrupt completion
// gateway sends an interrupt completion message, as a write to MMIO control register.

// Complete flow.
// The gateway will only forward a single interrupt request at a time to the PLIC, and not forward subsequent
//interrupts requests until an interrupt completion is received. The PLIC will set the IP bit once it accepts
//an interrupt request from the gateway, and sometime later forward an interrupt notification to the target.
//The target might take a while to respond to a new interrupt arriving, but will then send an interrupt claim
//request to the PLIC core to obtain the interrupt ID. The PLIC core will atomically return the ID and clear
//the corresponding IP bit, after which no other target can claim the same interrupt request. Once the handler
//has processed the interrupt, it sends an interrupt completion message to the gateway to allow a new interrupt
//request.

const PLIC_PRIORITY uint32 = 0x0c00_0000
const PLIC_PENDING uint32 = 0x0c00_1000
const PLIC_INT_ENABLE uint32 = 0x0c00_2000
const PLIC_THRESHOLD uint32 = 0x0c20_0000
const PLIC_CLAIM uint32 = 0x0c20_0004

// Assume we just have one source interrupt, UART
type Plic struct {
	Priority uint32
	// When an interrupt from source is set, the corresponding bit is set there
	Pending   []uint32
	Enable    uint32
	Threshold uint32
	Claim     uint32
	Complete  uint32
}

type InterruptSource struct {
	Pending bool
}

func (plic *Plic) Write(v uint32, addr uint32, cpu *Cpu) error {
	if addr == PLIC_PRIORITY {
		plic.Priority = v
	}

	// Doesn't do anything as of now
	if addr == PLIC_INT_ENABLE {
		plic.Enable = v
	}

	if addr == PLIC_THRESHOLD {
		plic.Threshold = v
	}

	// interrupt is completed here
	if addr == PLIC_CLAIM {
		if len(plic.Pending) > 0 && plic.Pending[0] == v {
			plic.Pending = plic.Pending[1:]
			// Set MIP to 0 here, as there is no pending interrupt now.
			// TODO: This is not completely correct, but should do for now
			cpu.CSR.Registers[MIP] = 0
			mstatus := ToMStatusReg(cpu.CSR.GetValue(MSTATUS, cpu.CurrentMode, cpu))
			mstatus.mie = 1
			cpu.CSR.Registers[MSTATUS] = FromMStatusReg(mstatus)
		}
	}

	return nil
}

func (plic *Plic) Read(addr uint32) uint32 {
	if addr == PLIC_CLAIM {
		if len(plic.Pending) == 0 {
			return 0
		}
		return plic.Pending[0]
	}

	if addr == PLIC_PENDING {
		if len(plic.Pending) > 0 {
			return plic.Pending[0]
		}
	}

	if addr == PLIC_INT_ENABLE {
		return plic.Enable
	}

	panic("This shouldn't happen")
}

func (plic *Plic) TriggerInterrupt(id uint32, cpu *Cpu) {
	if len(plic.Pending) > 0 {
		return
	}
	if cpu.CSR.Registers[MIP] > 0 {
		return
	}
	plic.Pending = append(plic.Pending, id)
	// also set flag of hart
	// 11 is external machine interrupt pending
	cpu.CSR.Registers[MIP] = cpu.CSR.Registers[MIP] | 1<<11
}
